
// # 累的一笔的中年人。。。
// # Java 对业务的支撑，每周五开周会，周四PM优先级排布，
// # 自研的MVC容器，springboot容器，依赖管理
// # 业务 短视频 内容供给 内容中心 内容加工 发布 审核。
// # 为什么做短视频？流量入口。抖音=》本地生活
// # 商务合作主要依赖PM，确定各方需求（oa系统，大象），业务系统 PM 需求产出很重
// # 工作时间 进度？ 10-9-5 打卡够9hr。only午餐，八点后才给餐补

// #     开发-提测-版本更新（一周左右上线，模块内）
// #     大的跨度（一个月，脉脉-交易 提单 保险金融支付；短视频）

/* 

介绍下领域驱动模式？
    在领域驱动设计（Domain-Driven Design，DDD）中，核心领域通常指的是业务中最关键、最重要的部分，它们对业务的成功至关重要。
    核心领域通常是需要深入理解、建模和设计的部分，以确保软件系统准确地反映了业务需求。

vmware 混合云的领域服务拆分哪些？
    VMware 混合云项目中的领域服务的拆分通常是为了将复杂的系统分解成更小、更易管理的部分，以便更好地实现领域驱动设计（DDD）和微服务架构的理念。拆分领域服务有助于提高系统的可维护性、可扩展性和灵活性。以下是一些可能在 VMware 混合云项目中拆分的领域服务：

        AWS Provider Service： 这个服务可能负责与 AWS 相关的基础设施资源管理，包括虚拟机实例、存储、网络配置等。拆分为独立的 AWS Provider Service 可以更好地管理 AWS 资源，并确保其与其他部分的隔离。

        AWS Orchestration Service： 这个服务可能负责协调和执行与 AWS 相关的异步工作流程，例如创建、更新或删除 AWS 资源。将它拆分成一个独立的服务可以使工作流程管理更具可扩展性。

        AWS Worker Service： 该服务可能负责为执行 AWS 操作提供计算资源。将它拆分为独立的服务有助于优化计算资源的分配和伸缩性。

        Inventory Service： Inventory Service 可能负责管理和存储来自不同基础架构提供商的库存资源元数据。这包括资源 ID、配置信息等。拆分为 Inventory Service 有助于维护跨多个基础架构提供商的资源信息。

        Activity Service： 该服务可能用于监控和管理云平台上运行的异步任务。将活动管理拆分为独立服务可以提供更好的故障处理和可扩展性。

    这些领域服务的拆分将有助于更好地管理复杂性，每个服务可以专注于特定的领域，这样开发人员可以更容易地理解、维护和扩展每个服务。此外，微服务架构的采用还可以实现更高程度的独立性，使不同服务可以独立开发、测试和部署，从而提高整体系统的灵活性。这些服务可以通过明确定义的 API 进行通信，以实现协同工作。


java类加载？
    Java类加载是Java虚拟机（JVM）运行Java程序时的一个重要过程，它负责将编译后的Java字节码文件加载到内存中，并转换为可执行的Java类。类加载是Java程序执行的第一阶段。类加载器（Class Loader）负责实际的加载过程。

    Java类加载分为以下几个阶段：

    加载（Loading）： 在加载阶段，类加载器从磁盘或网络加载字节码文件，然后将其存储在内存中。在这个阶段，字节码文件还没有被解析或链接，只是被加载到内存中。

    链接（Linking）： 链接分为三个子阶段：

        验证（Verification）： 在验证阶段，类加载器检查字节码文件的正确性，以确保它符合Java虚拟机规范，不包含不安全的操作。
        准备（Preparation）： 在准备阶段，类加载器为类的静态变量分配内存并设置默认初始值。这些变量在类加载后可用，但尚未初始化为用户定义的值。
        解析（Resolution）： 在解析阶段，虚拟机将符号引用转换为直接引用，以确保类与其他类的链接是正确的。例如，虚拟机将字段引用解析为实际内存地址。
    初始化（Initialization）： 在初始化阶段，类加载器执行类的静态初始化器代码块，初始化静态变量。这个阶段会触发类构造器方法（<clinit>）的执行，确保类的静态状态正确初始化。

    类加载器（ClassLoader）是Java类加载的关键组件，它负责查找和加载类文件。Java有三个内置的类加载器：

        Bootstrap ClassLoader： 它是Java虚拟机的一部分，用于加载核心Java类，通常在JVM启动时加载。

        Extension ClassLoader： 也称为扩展类加载器，用于加载JRE扩展目录中的类。

        Application ClassLoader： 也称为系统类加载器，用于加载应用程序的类，通常从类路径中加载。

maven 类冲突怎么处理？

    升级或降级依赖版本： 如果可能的话，尝试找到一个D的版本，既满足B的依赖（1.0版本），又满足C的依赖（2.0版本）。
    这可能需要查看D的更新日志或文档，以了解不同版本之间的差异和向后兼容性。你可以尝试将B和C都迁移到一个公共的D版本，以解决兼容性问题。

    使用类加载器隔离： 在某些情况下，你可以使用Java的类加载器隔离机制来处理类加载冲突。
        你可以创建自定义类加载器，将B和其依赖（D的1.0版本）加载到一个隔离的类加载器中，然后将C和其依赖（D的2.0版本）加载到另一个隔离的类加载器中。
        这样可以使它们在不同的命名空间中运行，避免类加载冲突。请注意，类加载器隔离可能会引入一些复杂性，需要小心使用。

    排除依赖并手动管理： 如果D的不同版本之间的冲突无法解决，你可以考虑手动管理D的依赖。在B和C的pom.xml文件中，排除D的依赖，然后手动将D的1.0版本或2.0版本


tomcat 解决方案？
    A 依赖B C
    B - D1.0
    C - D2.0

ChatGPT
在这种情况下，A依赖于B和C，但B和C又依赖于不同版本的D，即B依赖D的1.0版本，而C依赖D的2.0版本。这可能会导致冲突，因为D的1.0版本和2.0版本不兼容。

解决这种依赖冲突的一种常见方法是使用Tomcat的隔离类加载器（ClassLoader）来确保B和C的依赖不会互相干扰，从而避免冲突。你可以按照以下步骤来解决问题：

创建两个Web应用程序： 将A的功能拆分为两个独立的Web应用程序，例如，将A的功能分别部署到两个不同的WAR文件，例如A.war和B.war。

在Tomcat中部署两个应用程序： 使用Tomcat容器，将A.war和B.war两个Web应用程序部署到Tomcat。

使用隔离的类加载器： 在Tomcat中，每个Web应用程序都有自己的类加载器。你可以配置Tomcat，以便每个Web应用程序都使用自己的类加载器，这样它们不会互相干扰。这可以通过修改Tomcat的上下文配置文件（context.xml）来实现。

在A.war的context.xml中，配置一个类加载器：
xml
Copy code
<Context>
    <Loader loaderClass="org.apache.catalina.loader.ParallelWebappClassLoader" />
</Context>

在B.war的context.xml中，也配置一个类加载器：
xml
Copy code
<Context>
    <Loader loaderClass="org.apache.catalina.loader.ParallelWebappClassLoader" />
</Context>

这将使A和B分别使用独立的类加载器加载它们的依赖，避免冲突。

部署和访问： 部署A.war和B.war后，你可以通过访问各自的URL来访问它们的功能。由于它们使用不同的类加载器，B的依赖版本与C的依赖版本不会相互干扰。
这种方法允许你在Tomcat中隔离依赖冲突的不同版本，确保它们在各自的Web应用程序中独立运行。请注意，这种方法可能需要对Tomcat的配置文件和部署结构进行更改，因此需要小心操作。


了解 java hashmap吗? 底层实现？
    
    HashMap是Java中的一种常用的数据结构，它用于存储键-值对，并提供快速的查找、插入和删除操作。HashMap基于哈希表实现，具有O(1)的平均时间复杂度，适用于需要高效查找和插入操作的场景。
    
    Java中的HashMap是基于哈希表（Hash Table）实现的，具体来说，它是基于数组和链表/红黑树的结构。HashMap的底层数据结构主要包括以下两部分：
    数组（Array）： HashMap使用一个数组来存储元素。这个数组的每个元素被称为桶（Bucket）。数组的大小是固定的，但根据HashMap的实现，可以动态调整大小以处理负载因子。
    链表/红黑树（LinkedList/Red-Black Tree）： 在每个桶中，可以存储一个或多个键-值对。这些键-值对以链表或红黑树的形式存储在桶内。通常情况下，
    每个桶中只有一个键-值对，但如果发生哈希冲突（多个不同键映射到相同桶），则使用链表或红黑树来存储冲突的键-值对。


快速排序（Quick Sort）实现？
    
    是一种常用的排序算法，它基于分治策略，通过选择一个基准元素，将数组分为两个子数组，其中一个子数组的元素都小于基准元素，另一个子数组的元素都大于基准元素，然后对这两个子数组分别进行递归排序。

    选择基准元素（Pivot）： 从待排序数组中选择一个元素作为基准元素。通常选择第一个元素、最后一个元素或随机选择一个元素作为基准元素。

分区（Partition）： 将数组中的元素分为两部分，使得左边部分的元素都小于基准元素，右边部分的元素都大于基准元素。这个过程称为分区。具体分区的步骤如下：

    设置两个指针，一个指向数组的起始位置，一个指向数组的末尾。
    移动左指针，直到找到一个大于或等于基准元素的元素。
    移动右指针，直到找到一个小于或等于基准元素的元素。
    如果左指针仍然在右指针的左侧，交换左右指针所指的元素，然后继续移动指针。
    重复上述步骤，直到左指针大于等于右指针。
    递归排序： 对分区后的两个子数组（左边部分和右边部分）分别进行递归排序。递归排序的终止条件是子数组的大小为1或0，因为一个元素或没有元素的数组可以视为已排序。

合并： 合并已排序的子数组，得到最终的排序结果。

下面是一个具体示例，演示了如何使用快速排序对数组进行排序：

    假设有数组 [5, 2, 9, 3, 6, 1, 8, 4, 7]：

    选择基准元素，例如选择第一个元素5。
    分区过程：
    左指针从第二个元素2开始，右指针从最后一个元素7开始。
    左指针移动到3，右指针移动到4，交换它们。
    左指针移动到6，右指针移动到3，交换它们。
    左指针移动到1，右指针移动到2，交换它们。
    左指针大于等于右指针，分区完成。
    分区后的数组变为 [1, 2, 3, 4, 5, 6, 8, 9, 7]。
    递归排序左边部分 [1, 2, 3, 4] 和右边部分 [6, 8, 9, 7]。
    递归排序左边部分 [1, 2] 和右边部分 [4, 3]。
    递归排序左边部分 [1] 和右边部分 [2]，它们都已排序。
    合并左边部分 [1, 2]，得到 [1, 2]。
    递归排序左边部分 [4] 和右边部分 [3]，它们都已排序。
    合并右边部分 [3, 4]，得到 [3, 4]。
    合并左边部分 [1, 2] 和右边部分 [3, 4]，得到 [1, 2, 3, 4]。
    依此类推，最终得到排序后的数组 [1, 2, 3, 4, 5, 6, 7, 8, 9]。
    这就是快速排序的基本思路，它的平均时间复杂度为O(n log n)，是一种高效的排序算法。


TCP 阻塞控制

    TCP（传输控制协议）拥塞控制是一种网络拥塞管理机制。TCP拥塞控制主要由以下几个机制组成：

        拥塞窗口（Congestion Window）： 拥塞窗口是发送方允许在不收到确认的情况下发送的数据量的上限。发送方根据网络的状况来动态调整拥塞窗口的大小。

        慢启动（Slow Start）： 当连接建立时，拥塞窗口的大小初始化为一个较小的值。然后，每当数据包被确认，拥塞窗口的大小会加倍，以实现快速增加传输速率。这个过程称为慢启动。

        拥塞避免（Congestion Avoidance）： 一旦拥塞窗口的大小达到一定阈值，TCP连接就进入拥塞避免阶段。在这个阶段，拥塞窗口的大小以线性方式增加，而不再是指数增长，以避免引起网络拥塞。

        快速重传和快速恢复（Fast Retransmit and Fast Recovery）： 如果发送方在一段时间内没有收到来自接收方的确认，它将重传丢失的数据包，而不等待超时。此时，拥塞窗口的大小会减半，但不会回到慢启动的起始阈值。

        超时重传（Timeout Retransmit）： 如果发送方在一定时间内没有收到确认，并且未采用快速重传，它将假定数据包丢失，触发拥塞控制机制，将拥塞窗口的大小减小到一个较小的值，然后重新发送数据。

        拥塞信号（Congestion Signal）： 拥塞信号是网络中的路由器向发送方发送的信息，指示网络存在拥塞。发送方会根据这些信号来调整拥塞窗口的大小。

    TCP拥塞控制的主要目标是避免网络拥塞，同时提供公平性，即不让某个TCP连接占用过多网络资源，从而导致其他连接性能下降。TCP通过动态调整拥塞窗口的大小来实现这些目标，以适应网络的变化。

    总的来说，TCP拥塞控制是一种关键的网络管理机制，有助于维持网络的稳定性和性能，并确保数据的可靠传输。


zookeeper解释
    ZooKeeper（中文通常称为动物园管理员或动物园卫士）是一个分布式协调服务，旨在协助构建分布式应用程序和服务。
    它提供了一个分布式的、高性能的协调服务，用于解决分布式系统中的一些关键问题，如分布式锁、配置管理、分布式通知、领导者选举等。

    以下是一些关键特点和功能，以解释 ZooKeeper：

        分布式协调： ZooKeeper旨在帮助分布式系统协调和管理资源，以确保数据的一致性和可靠性。

        高性能： ZooKeeper是高性能的，能够在分布式环境中快速处理请求。

        数据结构： ZooKeeper提供了一个分层的文件系统结构，用于存储配置信息和其他数据。类似于文件系统中的目录和文件。

        监听和通知： ZooKeeper允许客户端注册对数据节点的监听，以便在数据发生更改时通知相关客户端。

        分布式锁： ZooKeeper提供分布式锁的支持，允许多个进程安全地协作，以防止竞争条件和资源冲突。

        领导者选举： ZooKeeper可以用于选举领导者（leader），这在分布式系统中非常有用，以确保某个节点负责协调任务。

        容错性： ZooKeeper被设计成具有高度的容错性，能够处理节点故障和网络分区的情况。

        数据一致性： ZooKeeper强调数据的一致性，保证一致性对于许多分布式应用程序非常重要。

        轻量级： ZooKeeper的设计是相对轻量级的，因此可以在各种环境中部署和使用。


zookeeper节点类型?

    持久节点（Persistent Nodes）： 持久节点是最基本的节点类型，它们在创建后会一直存在，直到显式删除。持久节点通常用于存储配置信息、元数据和其他不会随时间变化的数据。这些节点不受客户端连接状态的影响，一旦创建，它们将一直存在。

    临时节点（Ephemeral Nodes）： 临时节点是与客户端连接相关的节点，当创建它们的客户端会话结束时，这些节点将被自动删除。临时节点通常用于实现临时锁、会话管理和动态成员注册等场景。它们对于实现短期任务和临时状态非常有用。

    持久顺序节点（Persistent Sequential Nodes）： 持久顺序节点类似于持久节点，但它们具有一个唯一的、自动分配的顺序编号。这些节点的名称会在其基础名称后面追加一个递增的编号。持久顺序节点用于创建全局唯一的节点名称，同时保持节点的持久性。

    临时顺序节点（Ephemeral Sequential Nodes）： 临时顺序节点结合了临时节点和持久顺序节点的特性。它们在客户端会话结束时会被自动删除，并具有唯一的顺序编号。这些节点常用于创建有序锁、领导者选举和队列等功能。


持久节点（Persistent Nodes）和 临时节点（Ephemeral Nodes）应用场景?

持久节点（Persistent Nodes）的应用场景：

    配置管理： 持久节点通常用于存储配置信息和元数据。这些数据通常不会频繁更改，因此可以创建为持久节点，确保它们在ZooKeeper中持久存在，供所有客户端访问。

    注册服务： 在分布式系统中，服务可以注册为持久节点，以通知其他服务或客户端关于它们的存在和可用性。这对于服务发现非常有用。

    主控节点（Leader Node）： 在领导者选举算法中，候选节点通常会将其竞选信息存储为持久节点，以便在节点故障后能够继续使用。

    系统元数据： 分布式系统中的一些元数据，如集群配置、版本信息等，可以存储为持久节点，以供所有节点访问。

临时节点（Ephemeral Nodes）的应用场景：

    会话管理： 临时节点通常用于管理客户端与ZooKeeper服务器之间的会话。当客户端与ZooKeeper建立连接时，它可以创建临时节点来表示其在线状态。当会话结束时，这些节点会被自动删除，用于实现会话管理。

    分布式锁： 临时节点常用于实现分布式锁。当一个客户端获得锁时，它创建一个临时节点，释放锁时，临时节点被删除。

    临时成员注册： 在分布式系统中，成员节点可以注册为临时节点，以通知其他成员关于其在线状态。这对于动态成员管理和协作非常有用。

    有序锁和队列： 临时顺序节点可用于创建全局唯一的节点名称，并与分布式队列、有序锁等功能结合使用。

总的来说，持久节点适用于存储持久性数据和元数据，而临时节点适用于管理会话、实现锁和通知在线状态等动态信息。根据具体的分布式应用场景和需求，可以选择使用适当类型的节点。



leader选举？

    领导者选举（Leader Election）是分布式系统中一种重要的协调机制，用于选择一台节点作为领导者，以协调和管理分布式任务。领导者选举通常用于解决以下问题：

    任务协调： 在分布式系统中，领导者通常负责协调任务的执行，分配工作，以确保任务按顺序执行。其他节点则作为工作者，执行领导者分配的任务。

    单点管理： 领导者选举有助于将系统的管理职责集中在一台节点上，而其他节点则专注于执行任务。这有助于减少分布式系统的复杂性。

    故障恢复： 当领导者节点发生故障或不可用时，领导者选举机制能够快速选择新的领导者，以确保系统的连续运行。

    资源分配： 领导者可以协调资源分配，以避免冲突和资源争夺，从而提高系统效率。

    在ZooKeeper等分布式协调服务中，领导者选举通常使用以下步骤进行：

        节点注册： 候选节点在ZooKeeper中创建一个临时节点，表示其候选领导者状态。这可以是临时节点或临时顺序节点，具体取决于选举算法。

        选举算法： 分布式系统中使用不同的选举算法来选择领导者。常见的算法包括Paxos、Raft和基于ZooKeeper的选举算法。这些算法确保只有一个节点最终成为领导者。

        投票和通信： 候选节点相互通信以获取投票，并根据选举算法的规则决定谁应该成为领导者。节点会在ZooKeeper中创建节点并修改状态，以反映其投票决策。

        领导者通知： 一旦一个节点被选为领导者，它会更新ZooKeeper中的节点状态，通知其他节点。其他节点检测到领导者变化后，可以执行新领导者的命令。

        领导者选举是分布式系统中的关键机制，确保系统的一致性和高可用性。选举算法的设计和实现是分布式系统领域的重要研究方向，不同的算法可以适应不同的应用场景和性能需求。


Raft实现原理?

    Raft是一种分布式一致性算法，旨在解决分布式系统中的数据一致性和领导者选举问题。Raft的设计目标是提供更容易理解和实现的分布式一致性，相对于Paxos等算法，Raft更加容易被开发者理解和实现。以下是Raft算法的核心原理：

    领导者选举： Raft将时间划分为一系列的术语（Terms）。在每个术语中，节点可以竞选成为领导者。领导者选举通过以下方式进行：

    节点开始选举后成为候选者（Candidate）。
    候选者向其他节点发送投票请求。
    其他节点可以投票给候选者，如果候选者获得多数投票，它成为领导者。
    领导者在术语中负责处理客户端请求和复制日志等任务。
    复制日志： Raft使用日志来实现数据一致性。领导者负责接收客户端的写请求，将写操作附加到日志中，并将日志条目复制给其他节点。一旦多数节点确认接收并应用了相同的日志条目，该日志条目被视为已提交。这确保了数据的一致性。

    安全性： Raft确保了一致性和安全性，因为只有具有最新日志的节点可以成为领导者。如果一个节点的日志不完整或过时，它不会被选为领导者。

    领导者权威： Raft中的领导者是唯一有权力向客户端发送响应的节点。领导者处理客户端请求并将其复制到其他节点。其他节点只是按照领导者的指示执行操作。

    快照： Raft支持快照机制，以避免不断增长的日志占用过多存储空间。快照是对数据状态的快照，可以在数据状态发生大规模变化时创建，以便日志截断。

    Raft算法的关键思想是通过领导者选举和日志复制来确保一致性。Raft将整个分布式系统分为多个术语，并在每个术语中选举领导者。这个领导者负责处理客户端请求和维护日志的一致性。Raft的设计和算法规则更加清晰和易于理解，使其在分布式系统中得到广泛应用。这使得开发者更容易实现和维护Raft算法的实现。

*/

import java.util.*;

public class Main{
    
    public static int[] merge(int[] arr1, int[] arr2){
        
        if(arr1==null || arr1.length == 0 || arr1.length > 100){
            return arr2;
        }
        if(arr2==null || arr2.length == 0 || arr2.length > 100){
            return arr1;
        }
        
        int len1 = arr1.length;
        int len2 = arr2.length;
        int[] res = new int[len1 + len2];
        int i=0, j=0, k=0;
        
        while(i < len1 && j < len2){
            if (arr1[i] < arr2[j]){
                res[k++] = arr1[i++];
            } else {
                res[k++] = arr2[j++];
            }
        }
        while (i < len1){
            res[k++] = arr1[i++];
        }
        while (j < len2){
            res[k++] = arr2[j++];
        }
//         System.out.println("test" + res[4]);
        return res;
    }    

    public static void main(String[] args) {
        //Scanner in = new Scanner(System.in);
        //int a = in.nextInt();
        //System.out.println(a);
        int[] arr1= {1,2,3};
        int[] arr2= {4,5,6};
        int[] merged = merge(arr1, arr2);
        
        System.out.println("test1 merged arr: ");
        for (int n  : merged){
            System.out.println(n + " ");
        }
        
        int[] arr11= {1,4,6};
        int[] arr22= {2,4,9};
        merged = merge(arr11, arr22);
        
        System.out.println("test2 merged arr: ");
        for (int n  : merged){
            System.out.println(n + " ");
        }
        
        int[] arr111= {};
        int[] arr222= {};
        merged = merge(arr111, arr222);
        
        System.out.println("test3 merged arr: ");
        for (int n  : merged){
            System.out.println(n + " ");
        }
        
    }
}